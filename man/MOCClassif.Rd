% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MOCClassif.R
\name{MOCClassif}
\alias{MOCClassif}
\title{MOC (Multi-objective counterfactual explanations) for Classification Tasks}
\description{
\code{MOC} (Dandl et. al 2020) solves a multi-objective optimization problem to find counterfactuals. The four objectives
to minimize are:
\enumerate{
\item {Distance between \code{x_interest} and \code{desired_prob}}
\item {Distance between \code{x_interest} and a candidate}
\item {Number of feature changes}
\item {(Weighted) average distance between a candidate and its \code{k} nearest observed data points}
}

For optimization it uses the NSGA II algorithm (Deb et. al 2002) with mixed integer evolutionary
strategies by Li et al. (2013).
}
\details{
Several population initialization strategies are available:
\enumerate{
\item {\code{random}: Sample from numerical feature ranges and discrete feature values from \code{predictor$data$X}.
Some features values are randomly reset to the values of \code{x_interest}.}
\item {\code{icecurve}: Sample from numerical feature ranges and discrete feature values from \code{predictor$data$X}.
The higher the ICE curve variance of a feature, the lower the probability that
values of this feature are reset to the values of \code{x_interest}.}
\item {\code{sd}: Sample from numerical feature ranges that are limited by the feature standard deviations extracted
from \code{predictor$data$X}. For non-numerical features, the \code{random} strategy is used.
Some features values are randomly reset to the values of \code{x_interest}.}
\item {\code{traindata}: Initializes the first population using observations from \code{predictor$data$X} that are nondominated.
Some features values are randomly reset to the values of \code{x_interest}. If not enough nondominated observations are found,
remaining individuals are created using the \code{random} strategy.}
}

The R package \code{miesmuschel} implements the mixed integer evolutionary strategies.\cr
To compute dissimilarities, the function uses Gower's dissimilarity measure (Gower, 1990),
which is implemented in the \link[StatMatch]{gower.dist}.
}
\examples{
if (require("randomForest")) {
  # Train a model
  rf = randomForest(Species ~ ., data = iris)
  # Create a predictor object
  predictor = iml::Predictor$new(rf, type = "prob")
  # Find counterfactuals
  moc_classif = MOCClassif$new(predictor, n_generations = 30L)
  cfactuals = moc_classif$find_counterfactuals(
    x_interest = iris[150L, ], desired_class = "versicolor", desired_prob = c(0.5, 1)
  )
  # Print the results
  cfactuals$data
  # Plot evolution
  moc_classif$plot_statistics()
}


}
\references{
Dandl, Susanne, Christoph Molnar, Martin Binder, and Bernd Bischl. 2020. “Multi-Objective Counterfactual Explanations.”
In Parallel Problem Solving from Nature – PPSN XVI, edited by Thomas Bäck, Mike Preuss, André Deutz, Hao Wang, Carola Doerr,
Michael Emmerich, and Heike Trautmann, 448–69. Cham: Springer International Publishing.

Deb, K., Pratap, A., Agarwal, S., & Meyarivan, T. A. M. T. (2002). A fast and elitist multiobjective genetic algorithm: NSGA-II.
IEEE transactions on evolutionary computation, 6(2), 182-197.

Gower, J. C. (1971), "A general coefficient of similarity and some of its properties". Biometrics, 27, 623–637.

R. Li et al., "Mixed Integer Evolution Strategies for Parameter Optimization," in Evolutionary Computation, vol. 21, no. 1,
pp. 29-64, March 2013, doi: 10.1162/EVCO_a_00059.
}
\section{Super classes}{
\code{\link[counterfactuals:CounterfactualMethod]{counterfactuals::CounterfactualMethod}} -> \code{\link[counterfactuals:CounterfactualMethodClassif]{counterfactuals::CounterfactualMethodClassif}} -> \code{MOCClassif}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{optimizer}}{(\link[bbotk]{OptimInstanceMultiCrit}) \cr
The object used for optimization.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{MOCClassif$new()}}
\item \href{#method-plot_statistics}{\code{MOCClassif$plot_statistics()}}
\item \href{#method-get_dominated_hv}{\code{MOCClassif$get_dominated_hv()}}
\item \href{#method-plot_search}{\code{MOCClassif$plot_search()}}
\item \href{#method-clone}{\code{MOCClassif$clone()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethod" data-id="print">}\href{../../counterfactuals/html/CounterfactualMethod.html#method-print}{\code{counterfactuals::CounterfactualMethod$print()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="counterfactuals" data-topic="CounterfactualMethodClassif" data-id="find_counterfactuals">}\href{../../counterfactuals/html/CounterfactualMethodClassif.html#method-find_counterfactuals}{\code{counterfactuals::CounterfactualMethodClassif$find_counterfactuals()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new MOCClassif object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MOCClassif$new(
  predictor,
  epsilon = NULL,
  fixed_features = NULL,
  max_changed = NULL,
  mu = 20L,
  n_generations = 175L,
  p_rec = 0.57,
  p_rec_gen = 0.85,
  p_rec_use_orig = 0.88,
  p_mut = 0.79,
  p_mut_gen = 0.56,
  p_mut_use_orig = 0.32,
  k = 1L,
  weights = NULL,
  lower = NULL,
  upper = NULL,
  init_strategy = "random",
  use_conditional_mutator = FALSE,
  quiet = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{predictor}}{(\link[iml]{Predictor})\cr
The object (created with \code{iml::Predictor$new()}) holding the machine learning model and the data.}

\item{\code{epsilon}}{(\code{numeric(1)} | \code{NULL})\cr
If not \code{NULL}, candidates whose prediction is farther away from the desired prediction than epsilon are penalized.
\code{NULL} (default) means no penalization}

\item{\code{fixed_features}}{(\code{character()} | \code{NULL})\cr
Names of features that are not allowed to be changed. \code{NULL} (default) allows all features to be changed.}

\item{\code{max_changed}}{(\code{integerish(1)} | \code{NULL})\cr
Maximum number of feature changes. \code{NULL} (default) allows any number of changes.}

\item{\code{mu}}{(\code{integerish(1)})\cr
The population size. Default is \code{20L}.}

\item{\code{n_generations}}{(\code{integerish(1)})\cr
The number of generations. Default is \code{175L}.}

\item{\code{p_rec}}{(\code{numeric(1)})\cr
Probability with which an individual is selected for recombination. Default is \code{0.57}.}

\item{\code{p_rec_gen}}{(\code{numeric(1)})\cr
Probability with which a feature/gene is selected for recombination. Default is \code{0.85}.}

\item{\code{p_rec_use_orig}}{(\code{numeric(1)})\cr
Probability with which a feature/gene is reset to the feature value of \code{x_interest} after recombination. Default is \code{0.88}.}

\item{\code{p_mut}}{(\code{numeric(1)})\cr
Probability with which an individual is selected for mutation. Default is \code{0.79}.}

\item{\code{p_mut_gen}}{(\code{numeric(1)})\cr
Probability with which a feature/gene is selected for mutation. Default is \code{0.56}.}

\item{\code{p_mut_use_orig}}{(\code{numeric(1)})\cr
Probability with which a feature/gene is reset to the feature value of \code{x_interest} after mutation. Default is \code{0.32}.}

\item{\code{k}}{(\code{integerish(1)})\cr
The number of nearest neighbors to use for the forth objective. Default is \code{1L}.}

\item{\code{weights}}{(\code{numeric(1) | numeric(k)} | \code{NULL})\cr
The weights used to compute the weighted average distance for the forth objective. It is either a single value
or a vector of length \code{k}. If it has length \code{k}, the first value corresponds to the nearest neighbor and so on.
The values should sum up to \code{1}. \code{NULL} (default) means all neighbors are weighted equally.}

\item{\code{lower}}{(\code{numeric()} | \code{NULL})\cr
Vector of minimum values for numeric features. If not \code{NULL}, it should be named with the corresponding feature names.
If \code{NULL} (default) \code{lower} is taken for each numeric feature as its minimum value in \code{predictor$data$X}.}

\item{\code{upper}}{(\code{numeric()} | \code{NULL})\cr
Vector of maximum values for numeric features. If not \code{NULL}, it should be named with the corresponding feature names.
If \code{NULL} (default) \code{upper} is taken for each numeric feature as its maximum value in \code{predictor$data$X}.}

\item{\code{init_strategy}}{(\code{character(1)})\cr
The population initialization strategy. Can be \code{random} (default), \code{sd}, \code{icecurve} or \code{traindata}. For more information,
see the \code{details} section.}

\item{\code{use_conditional_mutator}}{(\code{logical(1)})\cr
Should a conditional mutator be used? The conditional mutator generates plausible feature values based
on the values of the other feature. Default is \code{FALSE}.}

\item{\code{quiet}}{(\code{logical(1)})\cr
Should information about the optimization status be hidden? Default is \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_statistics"></a>}}
\if{latex}{\out{\hypertarget{method-plot_statistics}{}}}
\subsection{Method \code{plot_statistics()}}{
Plots the evolution of the mean and minimum objective values together with the dominated hypervolume over
the generations. All values for a generation are calculated based on all nondominated individuals of that generation.
For computing the dominated hypervolume the \code{miesmuschel:::domhv} function is used.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MOCClassif$plot_statistics(centered_obj = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{centered_obj}}{(\code{logical(1)})\cr
Should the objective values be centered? If set to \code{FALSE}, each objective value is visualized in a separate plot,
since they (usually) have different scales. If set to \code{TRUE} (default), they are visualized in a single plot.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_dominated_hv"></a>}}
\if{latex}{\out{\hypertarget{method-get_dominated_hv}{}}}
\subsection{Method \code{get_dominated_hv()}}{
Calculates the dominated hypervolume of each generation.
The \code{miesmuschel:::domhv} function is used for this.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MOCClassif$get_dominated_hv()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A \code{data.table} with the dominated hypervolume of each generation
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_search"></a>}}
\if{latex}{\out{\hypertarget{method-plot_search}{}}}
\subsection{Method \code{plot_search()}}{
Visualizes all individuals of all generations in a scatter plot with two objectives on the axes.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MOCClassif$plot_search(objectives = c("dist_target", "dist_x_interest"))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{objectives}}{(\code{character(2)})\cr
The two objectives to be shown in the plot. Possible values are: "dist_target", "dist_x_interest, "nr_changed"
and "dist_train".}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MOCClassif$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
